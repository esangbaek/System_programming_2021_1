MAIN	START	1000
	JSUB	STKINIT
	LDA	ZERO
	TD	INDEV
	JEQ	MAIN
	RD	INDEV	.READ MATRIX SIZE
	SUB	#48
	STA	SIZE
	RD	INDEV
	JSUB	INPUT	.GET MATRIX INFO
	LDX	ZERO
	STX	ROW	.RESET ROW
	STX	CLM	.RESET COLUMN
	JSUB	PUSH
	J	QDTRE	.CALL QUAD_TREE FUNCTION
FINAL	LDA	ZERO
	J	FINAL

STKINIT	LDA	#CSTACK		.THIS IS A STACK TO STORE RETURN ADDRESS
	STA	TOP
	RSUB

.<<<################## CHECK FUNCTION ##################<<<

CHECK	LDA	SIZE		.THIS IS CHECK FUNCTION TO FIND OUT SECTION IS ALL SAME OR NOT
	MUL	SIZE
	STA	LEN		.TOTAL COMPARE COUNT
	LDA	CLM
	STA	CCLM
	LDA	ROW
	STA	CROW		
	MUL	#8
	ADD	CLM
	STA	TEMP
	LDX	TEMP		
	LDCH	MATRIX,X
	STA	PIVOT		.PIVOT SET
	LDA	SIZE
	COMP	#1		
	JEQ	ONEMAT		.IF IT IS SIZE ONE OR NOT
CKROW	LDA	CLM
	STA	CCLM	
	LDA	CROW		.CHECK RECURSIVE
	SUB	ROW
	COMP	SIZE
	JLT	CKCLM
	RSUB

CKCLM	LDA	CROW
	MUL	EIGHT
	STA	INDEX
	LDA	CROW
	ADD	#1
	STA	CROW
NXTROW	LDA	CCLM
	ADD	INDEX
	STA	BUFFER
	LDX	BUFFER
	LDCH	MATRIX,X
	COMP	PIVOT
	LDA	CCLM
	ADD	#1
	STA	CCLM
	JLT	RSTDIF
	JGT	RSTDIF
	LDA	LEN
	SUB	#1
	STA	LEN
	COMP	ZERO		.TO KNOW COMPARISION IS OVER OR NOT
	JEQ	RSTSAM		.QUIT FUNCTION BECAUSE SECTION IS ALL SAME
	LDA	CCLM
	SUB	CLM
	COMP	SIZE
	JLT	NXTROW
	JEQ	CKROW		.GO TO NEXT LINE

RSTSAM	LDA	#1		.SECTION IS ALL SAME		THEN RETURN 1
	STA	CHKRST
	RSUB

RSTDIF	LDA	#2		.SECTION IS NOT ALL SAME	THEN RETURN 2
	STA	CHKRST
	RSUB

ONEMAT	LDA	#1
	STA	CHKRST		.SECTION SIZE IS ONE		THEN RETURN 1
	RSUB

.>>>################## CHECK FUNCTION ##################>>>

.<<<################## QUAD TREE FUNCTION ##################<<<

QDTRE	TD	OUTDEV		.THIS IS QUAD_TREE FUNCTION (CAN BE RECURSIVE)
	JEQ	QDTRE
	JSUB	CHECK
	LDA	CHKRST
	COMP	#1
	JEQ	P1
	COMP	#2
	JEQ	RTWO
RETURN	JSUB	POP
	LDA	@TOP
	STA	TEMP
	LDA	ZERO
	STA	@TOP
	J	@TEMP

.>>>################## QUAD TREE FUNCTION ##################>>>
RONE	TD	OUTDEV		.TO HANDLE RESULT ONE
	JEQ	RONE
	LDA	SIZE
	COMP	#1
	JEQ	P1
	LDA	#40		
	WD	OUTDEV		.PRINT '('
	LDA	PIVOT		
	WD	OUTDEV		.PRINT PIVOT
	LDA	#41		
	WD	OUTDEV		.PRINT ')'
	J	RETURN

P1	TD	OUTDEV
	JEQ	P1
	LDA	PIVOT
	WD	OUTDEV		.PRINT PIVOT
	J	RETURN

RTWO	TD	OUTDEV		.TO HANDLE RESULT TWO
	JEQ	RTWO
	LDA	#40
	WD	OUTDEV
	LDA	SIZE
	DIV	#2
	STA	SIZE
	JSUB	PUSH
	J	QDTRE		.FIRST CALL	LEFT UP SECTION
	LDA	CLM
	ADD	SIZE
	STA	CLM
	JSUB	PUSH
	J	QDTRE		.SECOND CALL	RIGHT UP SECTION
	LDA	CLM
	SUB	SIZE
	STA	CLM		.SECOND
	LDA	ROW
	ADD	SIZE
	STA	ROW
	JSUB	PUSH
	J	QDTRE		.THIRD CALL	LEFT DOWN SECTION
	LDA	ROW
	SUB	SIZE
	STA	ROW		.THIRD
	LDA	ROW
	ADD	SIZE
	STA	ROW
	LDA	CLM
	ADD	SIZE
	STA	CLM
	JSUB	PUSH
	J	QDTRE		.FORTH CALL	RIGHT DOWN SECTION
	LDA	ROW
	SUB	SIZE
	STA	ROW
	LDA	CLM
	SUB	SIZE
	STA	CLM
	LDA	#41
	WD	OUTDEV
	LDA	SIZE
	MUL	#2
	STA	SIZE
	J	RETURN

.<<<################## GET INPUT FUNCTION ##################<<<

INPUT	J	SETROW
RESUME	LDA	ZERO
	STA	CLM	.COLUMN INDEX RESET
	LDA	ROW	.MATRIX[INDEX][]
	ADD 	#1
	STA	ROW
	COMP	SIZE
	JLT	INPUT
	RSUB

SETROW	LDA	ROW	.SET ROW'S ADDRESS
	MUL	EIGHT
	STA	INDEX
NXTLNE	TD	INDEV	.READ MATRIX[ROW][CLM]
	JEQ	NXTLNE
	RD	INDEV
	COMP	ENTER
	JEQ	RESUME	.GO RESUME TO GET NEXT LINE STRING
	LDS	INDEX	
	LDT	CLM
	ADDR	T, S
	STS	BUFFER
	LDX	BUFFER
	STCH	MATRIX,X
	LDA	CLM
	ADD	#1
	STA	CLM
	J	NXTLNE		.INPUT FUNCTION COMPLETED

.>>>################## GET INPUT FUNCTION ##################>>>
PUSH	LDA	#3
	ADDR	A,L
	STL	@TOP
	LDA	TOP
	ADD	#3
	STA	TOP
	LDA	#3
	SUBR	A,L
	RSUB

POP	LDA	TOP
	SUB	#3
	STA	TOP
	RSUB



INDEV	BYTE	0
OUTDEV	BYTE	1
ENTER	WORD	10	.ASCII CODE ENTER
ZERO	WORD	0
EIGHT	WORD	8
ROW	WORD	0	.GLOBAL VARIABLE TO INDICATE 'ROW'
CLM	WORD	0	.GLOBAL VARIABLE TO INDICATE 'COLUMN'
CROW	WORD	0	.CHECK FUNCTION LOCAL VARIABLE
CCLM	WORD	0	.CHECK FUNCTION LOCAL VARIABLE
BUFFER 	WORD	0
SAME	WORD	0
INDEX	WORD	0
CHKRST	WORD	0

LEN	RESW	1	.TO STORE TOTAL LOOP COUNT
PIVOT	RESW	1	.TO COMPARE MATRIX IS ALL SAME OR NOT
TEMP	RESW	1	.TEMPORARY VARIABLE
CSTACK	RESW	256	.CALL STACK
TOP	RESW	1	.TOP OF STACK
MATRIX	RESB	64	.MAX MATRIX SIZE=8*8=64
SIZE	RESW	1	.MATRIX : SIZE * SIZE